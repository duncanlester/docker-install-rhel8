#!/bin/bash

# Prompt for rules file and service
read -rp "Enter the fapolicyd rules file name (e.g., 99-docker.rules): " RULES_FILENAME
if [ -z "$RULES_FILENAME" ]; then
  echo "Rules file name is required. Exiting."
  exit 1
fi

RULES_FILE="/etc/fapolicyd/rules.d/$RULES_FILENAME"

# Check if script is running as root
if [[ $EUID -ne 0 ]]; then
   echo "❌ ERROR: This script must be run as root to modify fapolicyd rules"
   exit 1
fi

# Ensure rules directory exists
mkdir -p /etc/fapolicyd/rules.d

# Create rules file if it doesn't exist
if [ ! -f "$RULES_FILE" ]; then
    echo "Creating rules file: $RULES_FILE"
    touch "$RULES_FILE" || {
        echo "❌ ERROR: Cannot create rules file $RULES_FILE"
        exit 1
    }
fi

# Test if we can write to the rules file
if ! echo "# Generated by fapolicyd monitor script" >> "$RULES_FILE" 2>/dev/null; then
    echo "❌ ERROR: Cannot write to rules file $RULES_FILE"
    exit 1
fi

read -rp "Enter the service name (eg docker, jenkins, or 'all' for all binaries): " SERVICE
if [ -z "$SERVICE" ]; then
  echo "Service name is required. Exiting."
  exit 1
fi

echo "Starting fapolicyd monitoring for service: $SERVICE"

# Stop fapolicyd service and run debug mode with permissive flag
echo "Stopping fapolicyd service..."
systemctl stop fapolicyd

# Set fapolicyd to permissive mode so services can actually run while we develop rules
echo "Setting fapolicyd to permissive mode..."
sed -i.backup 's/^permissive.*/permissive = 1/' /etc/fapolicyd/fapolicyd.conf

echo "Starting fapolicyd in debug-deny mode..."

# Track when last denial occurred for this service and when monitoring started
LAST_DENIAL_TIME=$(date +%s)
START_TIME=$(date +%s)
NO_DENIAL_TIMEOUT=30
MAX_MONITOR_TIME=3600  # 1 hour

# Start fapolicyd in background and capture its output
echo "Launching fapolicyd --debug-deny --permissive..."
mkfifo /tmp/fapolicyd_output
fapolicyd --debug-deny --permissive > /tmp/fapolicyd_output 2>&1 &
FAPOLICYD_PID=$!

# Give fapolicyd time to fully initialize
echo "Waiting for fapolicyd to initialize (this may take up to 2 minutes)..."
sleep 10

# Check if fapolicyd process is still running
if ! kill -0 $FAPOLICYD_PID 2>/dev/null; then
    echo "❌ ERROR: fapolicyd failed to start in debug mode!"
    echo "Last few lines of output:"
    tail -n 10 /tmp/fapolicyd_output 2>/dev/null || echo "No output captured"
    rm -f /tmp/fapolicyd_output

    # Start normal service
    echo "Starting normal fapolicyd service..."
    # Restore original config if backup exists
    if [ -f /etc/fapolicyd/fapolicyd.conf.backup ]; then
        mv /etc/fapolicyd/fapolicyd.conf.backup /etc/fapolicyd/fapolicyd.conf
    fi
    systemctl restart fapolicyd
    exit 1
fi

echo "✓ Fapolicyd debug process is running (PID: $FAPOLICYD_PID)"
sleep 110  # Additional wait for full initialization

# Restart the service after debug mode is ready
if [ "$SERVICE" != "all" ] && systemctl list-unit-files | grep -q "^${SERVICE}.service"; then
    echo "Restarting $SERVICE service..."
    systemctl restart "$SERVICE" &
fi

# Monitor the output
{
    while IFS= read -r line < /tmp/fapolicyd_output; do
        if echo "$line" | grep -q 'decide access=execute.*denied'; then
                BIN_PATH=$(echo "$line" | awk -F 'path=' '{if (NF>1) print $2}' | awk '{print $1}')
                BIN_NAME=$(basename "$BIN_PATH")

                # Check if this denial is related to our service and update last denial time
                if [ "$SERVICE" = "all" ] || [[ "$BIN_NAME" == *"$SERVICE"* ]] || [[ "$BIN_PATH" == *"$SERVICE"* ]]; then
                        LAST_DENIAL_TIME=$(date +%s)
                fi

                # Add rule if binary path exists and not already in rules file
                if [ -n "$BIN_PATH" ] && ! grep -Fq "$BIN_NAME" "$RULES_FILE"; then
                        echo "Adding allow rule for $BIN_PATH ($BIN_NAME)"
                        RULE="allow perm=execute all : dir=$(dirname "$BIN_PATH")/ name=$BIN_NAME"
                        echo "$RULE" >> "$RULES_FILE"
                        if [ $? -eq 0 ]; then
                            echo "✓ Rule added successfully: $RULE"
                        else
                            echo "❌ ERROR: Failed to write rule to $RULES_FILE"
                        fi
                        echo "Restarting fapolicyd to apply new rule..."
                        # Kill the debug process
                        kill $FAPOLICYD_PID 2>/dev/null
                        # Start normal fapolicyd service to enforce new rules
                        systemctl restart fapolicyd
                        sleep 3
                        # Stop it again and restart debug mode
                        systemctl stop fapolicyd
                        fapolicyd --debug-deny --permissive > /tmp/fapolicyd_output 2>&1 &
                        FAPOLICYD_PID=$!
                        echo "Debug mode restarted with new rules"
                fi
        fi

        CURRENT_TIME=$(date +%s)

        # Check if we've been monitoring for the max time (1 hour)
        TOTAL_TIME=$((CURRENT_TIME - START_TIME))
        if [ $TOTAL_TIME -gt $MAX_MONITOR_TIME ]; then
                echo "Maximum monitoring time of 1 hour reached."
                echo "Stopping fapolicyd debug and restarting service..."
                kill $FAPOLICYD_PID 2>/dev/null
                break
        fi

        # Check if we should exit due to no service-specific denials
        TIME_DIFF=$((CURRENT_TIME - LAST_DENIAL_TIME))
        if [ $TIME_DIFF -gt $NO_DENIAL_TIMEOUT ]; then
                if [ "$SERVICE" = "all" ]; then
                        echo "No denials detected for $NO_DENIAL_TIMEOUT seconds."
                else
                        echo "No $SERVICE denials detected for $NO_DENIAL_TIMEOUT seconds."
                fi
                echo "Consider manually triggering $SERVICE operations if you expect more denials."
                echo "Stopping fapolicyd debug and restarting service..."
                kill $FAPOLICYD_PID 2>/dev/null
                break
        fi

        # Check if fapolicyd process is still running
        if ! kill -0 $FAPOLICYD_PID 2>/dev/null; then
            echo "❌ ERROR: fapolicyd debug process has died!"
            break
        fi
    done
} &
MONITOR_PID=$!

# Set up signal handling for cleanup
cleanup() {
    echo "Cleaning up..."
    kill $FAPOLICYD_PID 2>/dev/null
    kill $MONITOR_PID 2>/dev/null
    rm -f /tmp/fapolicyd_output
}
trap cleanup EXIT INT TERM

# Wait for monitoring to complete
wait $MONITOR_PID

# Restart fapolicyd service and restore enforcing mode
echo "Restarting fapolicyd service..."
# Restore original config
if [ -f /etc/fapolicyd/fapolicyd.conf.backup ]; then
    mv /etc/fapolicyd/fapolicyd.conf.backup /etc/fapolicyd/fapolicyd.conf
    echo "Restored original fapolicyd configuration"
else
    # Fallback: set to enforcing mode
    sed -i 's/^permissive.*/permissive = 0/' /etc/fapolicyd/fapolicyd.conf
    echo "Set fapolicyd to enforcing mode"
fi
systemctl restart fapolicyd
echo "Fapolicyd service restored to normal operation."

echo "Monitoring completed."

#!/bin/bash

# Prompt for rules file and service
read -rp "Enter the fapolicyd rules file name (e.g., 99-docker.rules): " RULES_FILENAME
if [ -z "$RULES_FILENAME" ]; then
  echo "Rules file name is required. Exiting."
  exit 1
fi

RULES_FILE="/etc/fapolicyd/rules.d/$RULES_FILENAME"

# Check if script is running as root
if [[ $EUID -ne 0 ]]; then
   echo "ERROR: This script must be run as root to modify fapolicyd rules"
   exit 1
fi

# Ensure rules directory exists
mkdir -p /etc/fapolicyd/rules.d

# Create rules file if it doesn't exist
if [ ! -f "$RULES_FILE" ]; then
    echo "Creating rules file: $RULES_FILE"
    touch "$RULES_FILE" || {
        echo "ERROR: Cannot create rules file $RULES_FILE"
        exit 1
    }
fi

# Test if we can write to the rules file
if ! echo "# Generated by fapolicyd monitor script" >> "$RULES_FILE" 2>/dev/null; then
    echo "ERROR: Cannot write to rules file $RULES_FILE"
    exit 1
fi

read -rp "Enter the service name (eg docker, jenkins, or 'all' for all binaries): " SERVICE
if [ -z "$SERVICE" ]; then
  echo "Service name is required. Exiting."
  exit 1
fi

echo "Starting fapolicyd monitoring for service: $SERVICE"

# Stop fapolicyd service and run debug mode with permissive flag
echo "Stopping fapolicyd service..."
systemctl stop fapolicyd

# Set fapolicyd to permissive mode so services can actually run while we develop rules
echo "Setting fapolicyd to permissive mode..."
sed -i.backup 's/^permissive.*/permissive = 1/' /etc/fapolicyd/fapolicyd.conf

echo "Starting fapolicyd in debug-deny mode..."

# Start fapolicyd and track timing
START_TIME=$(date +%s)
MAX_MONITOR_TIME=3600  # 1 hour

fapolicyd --debug-deny --permissive > /tmp/fapolicyd_output 2>&1 &
FAPOLICYD_PID=$!

sleep 120  # Wait for initialization

# Restart the service after debug mode is ready
if [ "$SERVICE" != "all" ] && systemctl list-unit-files | grep -q "^${SERVICE}.service"; then
    echo "Restarting $SERVICE service..."
    systemctl restart "$SERVICE" &
fi

# Monitor the output
{
    echo "Starting monitoring - will run for exactly 1 hour..."
    while true; do
        CURRENT_TIME=$(date +%s)

        # Check if we've been monitoring for the max time (1 hour) - PRIMARY CHECK
        TOTAL_TIME=$((CURRENT_TIME - START_TIME))
        if [ $TOTAL_TIME -gt $MAX_MONITOR_TIME ]; then
                echo "Maximum monitoring time of 1 hour reached."
                echo "Stopping fapolicyd debug and restarting service..."
                kill $FAPOLICYD_PID 2>/dev/null
                break
        fi

        # Check if fapolicyd process is still running
        if ! kill -0 $FAPOLICYD_PID 2>/dev/null; then
            echo "ERROR: fapolicyd debug process has died!"
            break
        fi

        # Read from fapolicyd with timeout to prevent hanging
        if IFS= read -t 5 -r line < /tmp/fapolicyd_output 2>/dev/null; then
            if echo "$line" | grep -q 'decide access=execute.*denied'; then
                    BIN_PATH=$(echo "$line" | awk -F 'path=' '{if (NF>1) print $2}' | awk '{print $1}')
                    BIN_NAME=$(basename "$BIN_PATH")

                    # Check if this denial is related to our service
                    if [ "$SERVICE" = "all" ] || [[ "$BIN_NAME" == *"$SERVICE"* ]] || [[ "$BIN_PATH" == *"$SERVICE"* ]]; then
                            # Add rule if binary path exists and not already in rules file
                            if [ -n "$BIN_PATH" ] && ! grep -Fq "$BIN_NAME" "$RULES_FILE"; then
                                    echo "Adding allow rule for $BIN_PATH ($BIN_NAME)"
                                    echo "allow perm=execute all : dir=$(dirname "$BIN_PATH")/ name=$BIN_NAME" >> "$RULES_FILE"
                            fi
                    fi
            fi
        fi

        # Show progress every 5 minutes
        if [ $((TOTAL_TIME % 300)) -eq 0 ] && [ $TOTAL_TIME -gt 0 ]; then
            REMAINING=$((MAX_MONITOR_TIME - TOTAL_TIME))
            echo "Still monitoring... $((REMAINING/60)) minutes remaining"
        fi
    done
} &
MONITOR_PID=$!

# Set up signal handling for cleanup
cleanup() {
    echo "Cleaning up..."
    kill $FAPOLICYD_PID 2>/dev/null
    kill $MONITOR_PID 2>/dev/null
    rm -f /tmp/fapolicyd_output
}
trap cleanup EXIT INT TERM

# Wait for monitoring to complete
wait $MONITOR_PID

# Restart fapolicyd service and restore enforcing mode
echo "Restarting fapolicyd service..."
# Restore original config
if [ -f /etc/fapolicyd/fapolicyd.conf.backup ]; then
    mv /etc/fapolicyd/fapolicyd.conf.backup /etc/fapolicyd/fapolicyd.conf
    echo "Restored original fapolicyd configuration"
else
    # Fallback: set to enforcing mode
    sed -i 's/^permissive.*/permissive = 0/' /etc/fapolicyd/fapolicyd.conf
    echo "Set fapolicyd to enforcing mode"
fi
systemctl restart fapolicyd
echo "Fapolicyd service restored to normal operation."

echo "Monitoring completed."
